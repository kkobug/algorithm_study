"""
비상연락망과 연락을 시작하는 당번에 대한 정보가 주어질 때,
가장 나중에 연락을 받게 되는 사람 중 번호가 가장 큰 사람을 구하는 함수를 작성하시오.
연락은 단방향으로 이루어지며 연락을 하는 사람은 해야하는 모든 사람에게 동시에 연락을 한다.

[제약 사항]
연락 인원은 최대 100명이며, 부여될 수 있는 번호는 1이상, 100이하이다.
단, 예시에서 5번이 존재하지 않듯이 중간 중간에 비어있는 번호가 있을 수 있다.
한 명의 사람이 다수의 사람에게 연락이 가능한 경우 항상 다자 간 통화를 통해 동시에 전달한다.
연락이 퍼지는 속도는 항상 일정하다 (전화를 받은 사람이 다음사람에게 전화를 거는 속도는 동일).
비상연락망 정보는 사전에 공유되며 한 번 연락을 받은 사람에게 다시 연락을 하는 일은 없다.
예시에서의 3, 6, 11, 22번과 같이 연락을 받을 수 없는 사람도 존재할 수 있다.
[입력]
입력의 첫 번째 줄에는 입력 받는 데이터의 길이와 시작점이 주어진다.
그 다음 줄에 입력받는 데이터는 {from, to, from, to, …} 의 순서로 해석된다.
주어지는 순서와 연락을 시행하는 순서는 상관이 없다.
[출력]
#부호와 함께 테스트 케이스의 번호를 출력하고, 공백 문자 후 테스트 케이스에 대한 답을 출력한다.

입력
24 2
1 17 3 22 1 8 1 7 7 1 2 7 2 15 15 4 6 2 11 6 4 10 4 2
출력
#1 17
"""
def bfs(Q):
    global ans
    new = []
    ans = max(Q)
    while Q:
        i = Q.pop()
        for k in contact[i]:
            if V[k]:
                continue
            new.append(k)
            V[k] = True
    if new:
        bfs(new)


for tc in range(1, 11):
    N, st = map(int, input().split())
    nums = list(map(int, input().split()))
    V = [False]*101
    contact = [[] for _ in range(101)]
    for i in range(0, N, 2):
        if nums[i+1] in contact[nums[i]]:
            continue
        contact[nums[i]].append(nums[i+1])
    ans = 0
    V[st] = True
    bfs([st])

    print(f'#{tc} {ans}')
